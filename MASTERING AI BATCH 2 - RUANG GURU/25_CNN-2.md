# CNN - Part 2 (Pre-trained Models & Object Detection)

## Pre-trained Models

### Apa itu Pre-trained Model?

Model CNN yang sudah ditraining dengan dataset besar (biasanya ImageNet) dan bisa digunakan untuk:
1. **Feature extraction:** gunakan sebagai feature extractor
2. **Transfer learning:** fine-tune untuk task kita
3. **Baseline model:** starting point yang kuat

**Keuntungan:**
- Tidak perlu training dari scratch
- Sudah belajar general features
- Hemat waktu dan resources
- Better performance dengan data terbatas

## Popular CNN Architectures

### 1. VGG (Visual Geometry Group)

**VGG16 dan VGG19:**
- Very deep network (16 atau 19 layers)
- Simple architecture: hanya Conv 3x3 dan MaxPool 2x2
- 138 juta parameter (VGG16)

**Karakteristik:**
- Stack Conv layers sebelum pooling
- Double number of filters setelah pooling
- Performance bagus tapi model besar

**Architecture:**
```
Input (224x224x3)
   ↓
Conv3-64 → Conv3-64 → MaxPool
   ↓
Conv3-128 → Conv3-128 → MaxPool
   ↓
Conv3-256 → Conv3-256 → Conv3-256 → MaxPool
   ↓
Conv3-512 → Conv3-512 → Conv3-512 → MaxPool
   ↓
Conv3-512 → Conv3-512 → Conv3-512 → MaxPool
   ↓
FC-4096 → FC-4096 → FC-1000
```

**Menggunakan VGG16:**
```python
from tensorflow.keras.applications import VGG16

# Load pre-trained model (without top FC layers)
base_model = VGG16(
    weights='imagenet',
    include_top=False,
    input_shape=(224, 224, 3)
)
```

### 2. ResNet (Residual Network)

**ResNet50, ResNet101, ResNet152:**
- Introduce "skip connections" atau "residual connections"
- Solve vanishing gradient problem
- Bisa very deep (50-152 layers)

**Skip Connection:**
```
Input → Conv → Conv → Add(Input) → Output
```
- Gradient bisa flow langsung
- Easier to optimize
- Identity mapping

**Karakteristik:**
- Residual blocks
- Batch normalization
- Global average pooling
- Lebih efisien dari VGG

**Code:**
```python
from tensorflow.keras.applications import ResNet50

base_model = ResNet50(
    weights='imagenet',
    include_top=False,
    input_shape=(224, 224, 3)
)
```

### 3. Inception (GoogLeNet)

**InceptionV3:**
- Inception modules (multiple filter sizes parallel)
- Factorized convolutions
- Efficient computation

**Inception Module:**
```
Input
  ↓
[1x1 Conv] [1x1 Conv→3x3 Conv] [1x1 Conv→5x5 Conv] [MaxPool→1x1 Conv]
  ↓           ↓                   ↓                    ↓
  └───────────┴───────────────────┴────────────────────┘
                          ↓
                    Concatenate
```

**Karakteristik:**
- Multi-scale feature extraction
- 1x1 convolutions untuk dimensionality reduction
- Auxiliary classifiers

**Code:**
```python
from tensorflow.keras.applications import InceptionV3

base_model = InceptionV3(
    weights='imagenet',
    include_top=False,
    input_shape=(224, 224, 3)
)
```

### 4. MobileNet

**MobileNetV2:**
- Designed untuk mobile dan embedded devices
- Depthwise separable convolutions
- Small dan fast

**Depthwise Separable Conv:**
- Depthwise: convolution per channel
- Pointwise: 1x1 convolution
- 8-9x less computation

**Karakteristik:**
- Lightweight (3.4M parameters)
- Fast inference
- Good accuracy-efficiency trade-off

**Code:**
```python
from tensorflow.keras.applications import MobileNetV2

base_model = MobileNetV2(
    weights='imagenet',
    include_top=False,
    input_shape=(224, 224, 3)
)
```

### 5. EfficientNet

**EfficientNetB0-B7:**
- Balance depth, width, resolution
- Compound scaling
- State-of-the-art efficiency

**Karakteristik:**
- Best accuracy per FLOPS
- Scalable architecture
- Transfer learning yang bagus

**Code:**
```python
from tensorflow.keras.applications import EfficientNetB0

base_model = EfficientNetB0(
    weights='imagenet',
    include_top=False,
    input_shape=(224, 224, 3)
)
```

## Transfer Learning Strategies

### 1. Feature Extraction

**Freeze semua layers, train classifier saja:**
```python
from tensorflow import keras

# Load base model
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224,224,3))

# Freeze base model
base_model.trainable = False

# Build model
model = keras.Sequential([
    base_model,
    keras.layers.GlobalAveragePooling2D(),
    keras.layers.Dense(256, activation='relu'),
    keras.layers.Dropout(0.5),
    keras.layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
```

**Kapan pakai:**
- Dataset kecil (ribuan images)
- Task similar dengan ImageNet
- Limited computational resources

### 2. Fine-Tuning

**Unfreeze beberapa layers dan train:**
```python
# First: train with frozen base
base_model.trainable = False
model.fit(X_train, y_train, epochs=10)

# Then: unfreeze and fine-tune
base_model.trainable = True

# Freeze early layers, unfreeze last layers
for layer in base_model.layers[:-30]:
    layer.trainable = False

# Compile with lower learning rate
model.compile(
    optimizer=keras.optimizers.Adam(1e-5),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Continue training
model.fit(X_train, y_train, epochs=10)
```

**Kapan pakai:**
- Dataset cukup besar (puluhan ribu images)
- Task agak berbeda dari ImageNet
- Ada GPU resources

### 3. Training from Scratch

**Initialize dengan ImageNet weights tapi train semua:**
```python
base_model.trainable = True

model.compile(
    optimizer=keras.optimizers.Adam(1e-4),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)
```

**Kapan pakai:**
- Dataset sangat besar
- Task sangat berbeda
- Domain-specific (medical, satellite, etc)

## Perbandingan Models

| Model | Params | Size | Top-1 Acc | Speed |
|-------|--------|------|-----------|-------|
| VGG16 | 138M | 528MB | 71.3% | Slow |
| ResNet50 | 25.6M | 98MB | 74.9% | Medium |
| InceptionV3 | 23.8M | 92MB | 77.9% | Medium |
| MobileNetV2 | 3.4M | 14MB | 71.3% | Fast |
| EfficientNetB0 | 5.3M | 29MB | 77.1% | Medium |

**Rekomendasi:**
- **Production (mobile):** MobileNet
- **Balanced:** ResNet50, EfficientNet
- **High accuracy:** InceptionV3, EfficientNetB7
- **Simple baseline:** VGG16

## Object Detection

### Classification vs Detection

**Image Classification:**
- One label per image
- "This is a cat"

**Object Detection:**
- Multiple objects per image
- Bounding box + class label
- "Cat at [x1, y1, x2, y2], Dog at [x3, y3, x4, y4]"

### Bounding Box

**Format:**
- **[x1, y1, x2, y2]:** top-left dan bottom-right corners
- **[x, y, w, h]:** center + width & height
- **Normalized:** [0, 1] relative to image size

### Object Detection Architectures

### 1. R-CNN Family

**R-CNN (Region-based CNN):**
1. Generate region proposals (~2000)
2. Run CNN pada tiap region
3. Classify tiap region
- Slow (forward pass 2000x)

**Fast R-CNN:**
1. Run CNN sekali pada whole image
2. ROI pooling pada feature map
3. Classify regions
- Faster tapi masih bottleneck di region proposals

**Faster R-CNN:**
1. RPN (Region Proposal Network) untuk generate proposals
2. ROI pooling
3. Classification + bounding box regression
- Fast dan accurate
- Two-stage detector

### 2. YOLO (You Only Look Once)

**Konsep:**
- Single-stage detector
- Divide image into grid
- Predict bounding boxes + class per grid cell
- Very fast (real-time)

**Architecture:**
```
Input Image
   ↓
CNN Backbone (Darknet)
   ↓
Feature Maps
   ↓
Detection Heads
   ↓
[Class Probabilities, Bounding Box, Confidence]
```

**Versions:**
- YOLOv1: first version
- YOLOv3: multi-scale predictions
- YOLOv5: user-friendly, PyTorch
- YOLOv8: latest, best performance

**YOLOv5 Usage:**
```python
import torch

# Load model
model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

# Inference
results = model('image.jpg')

# Show results
results.show()

# Get bounding boxes
boxes = results.xyxy[0]  # [x1, y1, x2, y2, confidence, class]
```

### 3. SSD (Single Shot Detector)

**Karakteristik:**
- Single-stage seperti YOLO
- Multi-scale feature maps
- Default boxes (anchor boxes)
- Balance speed dan accuracy

## Metrics untuk Object Detection

### 1. IoU (Intersection over Union)

**Formula:**
```
IoU = Area of Overlap / Area of Union
```

**Interpretation:**
- IoU > 0.5: good detection
- IoU > 0.7: very good
- IoU > 0.9: almost perfect

**Code:**
```python
def iou(box1, box2):
    # box format: [x1, y1, x2, y2]
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])
    
    intersection = max(0, x2-x1) * max(0, y2-y1)
    union = (box1[2]-box1[0])*(box1[3]-box1[1]) + \
            (box2[2]-box2[0])*(box2[3]-box2[1]) - intersection
    
    return intersection / union
```

### 2. Precision dan Recall

**Precision:**
```
Precision = TP / (TP + FP)
```
- Dari semua detections, berapa yang benar?

**Recall:**
```
Recall = TP / (TP + FN)
```
- Dari semua ground truth objects, berapa yang terdeteksi?

### 3. mAP (mean Average Precision)

**Average Precision (AP):**
- Area under precision-recall curve
- Per class

**mAP:**
- Mean of AP across all classes
- Standard metric untuk object detection

**Variants:**
- mAP@0.5: IoU threshold 0.5
- mAP@0.5:0.95: average across IoU 0.5 to 0.95

## Non-Maximum Suppression (NMS)

**Problem:** Multiple detections untuk same object

**Solution:**
1. Sort detections by confidence
2. Keep detection dengan confidence tertinggi
3. Remove detections dengan IoU > threshold (e.g., 0.5)
4. Repeat

**Code:**
```python
def nms(boxes, scores, threshold=0.5):
    # boxes: [N, 4]
    # scores: [N]
    
    indices = []
    sorted_indices = np.argsort(scores)[::-1]
    
    while len(sorted_indices) > 0:
        idx = sorted_indices[0]
        indices.append(idx)
        
        # Calculate IoU dengan boxes lain
        ious = [iou(boxes[idx], boxes[i]) for i in sorted_indices[1:]]
        
        # Keep boxes dengan IoU < threshold
        sorted_indices = sorted_indices[1:][np.array(ious) < threshold]
    
    return indices
```

## Practical Object Detection dengan YOLOv5

### Installation
```bash
pip install ultralytics
```

### Training Custom Dataset

**1. Prepare dataset:**
```
dataset/
  images/
    train/
    val/
  labels/
    train/
    val/
  data.yaml
```

**2. Label format (YOLO format):**
```
# One .txt file per image
# Format: class x_center y_center width height (normalized)
0 0.5 0.5 0.3 0.4
1 0.7 0.3 0.2 0.2
```

**3. data.yaml:**
```yaml
train: ./dataset/images/train
val: ./dataset/images/val

nc: 2  # number of classes
names: ['class1', 'class2']
```

**4. Training:**
```python
from ultralytics import YOLO

# Load model
model = YOLO('yolov5s.pt')

# Train
model.train(
    data='data.yaml',
    epochs=100,
    imgsz=640,
    batch=16
)
```

**5. Inference:**
```python
# Load trained model
model = YOLO('runs/train/exp/weights/best.pt')

# Predict
results = model('test.jpg')

# Visualize
results.show()
```

## Image Segmentation (Bonus)

### Semantic Segmentation
- Classify setiap pixel
- Same class objects treated sama
- Output: pixel-wise class map

### Instance Segmentation
- Separate individual objects
- Bounding box + mask per object
- Models: Mask R-CNN, YOLACT

## Tips Praktis

### 1. Model Selection
- **Real-time:** YOLO, MobileNet
- **High accuracy:** Faster R-CNN, EfficientDet
- **Balanced:** YOLOv8, SSD

### 2. Data Preparation
- Consistent annotation quality
- Enough samples per class (100+)
- Diverse backgrounds dan poses
- Data augmentation

### 3. Training
- Start dengan pre-trained weights
- Use appropriate image size (640x640 for YOLO)
- Monitor mAP, not just loss
- Early stopping based on mAP

### 4. Hyperparameters
- Learning rate: 0.01 (YOLO), 0.0001 (Faster R-CNN)
- Batch size: tergantung GPU (8-32)
- IoU threshold: 0.5 for NMS
- Confidence threshold: 0.25-0.5

## Key Takeaways

1. **Pre-trained models** save time dan improve performance
2. **Transfer learning strategies:** feature extraction, fine-tuning, training from scratch
3. **ResNet, Inception, EfficientNet** are popular choices
4. **Object detection** lebih complex dari classification
5. **YOLO popular** untuk real-time detection
6. **mAP standard metric** untuk evaluate detection
7. **NMS essential** untuk remove duplicate detections
8. **YOLOv5/v8 easy to use** untuk custom training
